#!/usr/bin/env node

/**
 * Generate Solidity verifiers from compiled circuits
 * Usage: npm run circuits:verifiers
 */

import { spawnSync } from "node:child_process";
import { existsSync, mkdirSync, readdirSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";

const CIRCUITS_DIR = join(process.cwd(), "circuits");
const BUILD_DIR = join(CIRCUITS_DIR, "build");
const VERIFIERS_DIR = join(process.cwd(), "contracts", "verifiers");

// Colors for terminal output
const colors = {
  reset: "\x1b[0m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  red: "\x1b[31m",
};

function log(message: string, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

function runCommand(command: string, args: string[]): void {
  let useShell = false;
  let executable = command;

  if (command === "pnpm" && process.platform === "win32") {
    useShell = true;
  }

  const result = spawnSync(executable, args, {
    stdio: "inherit",
    cwd: process.cwd(),
    shell: useShell,
  });

  if (result.error) {
    throw result.error;
  }
  if (result.status !== 0) {
    throw new Error(`Command "${command}" exited with code ${result.status}`);
  }
}

function capitalizeFirstLetter(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function formatContractName(circuitName: string): string {
  // Convert snake_case or kebab-case to PascalCase
  return circuitName
    .split(/[-_]/)
    .map(capitalizeFirstLetter)
    .join("");
}

async function generateVerifier(circuitName: string): Promise<void> {
  log(`\nüîß Generating verifier for ${circuitName}...`, colors.blue);

  const zkeyPath = join(BUILD_DIR, `${circuitName}.zkey`);
  const verifierPath = join(VERIFIERS_DIR, `${formatContractName(circuitName)}Verifier.sol`);

  if (!existsSync(zkeyPath)) {
    throw new Error(
      `zkey file not found for ${circuitName}. Run 'npm run circuits:compile' first.`
    );
  }

  // Generate verifier using snarkjs
  const tempVerifierPath = join(VERIFIERS_DIR, "temp_verifier.sol");
  
  log("   Generating Solidity verifier...", colors.yellow);
  runCommand("pnpm", [
    "exec",
    "snarkjs",
    "zkey",
    "export",
    "solidityverifier",
    zkeyPath,
    tempVerifierPath,
  ]);

  // Read and customize the verifier
  let verifierContent = readFileSync(tempVerifierPath, "utf-8");

  // Update contract name
  const contractName = `${formatContractName(circuitName)}Verifier`;
  verifierContent = verifierContent.replace(
    /contract Groth16Verifier/g,
    `contract ${contractName}`
  );

  // Update Solidity version to match project (handle both >=0.7.0 <0.9.0 and ^0.x.x formats)
  verifierContent = verifierContent.replace(
    /pragma solidity [^;]+;/,
    "pragma solidity ^0.8.20;"
  );

  // Replace the entire header section with our custom header
  const header = `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title ${contractName}
 * @notice Groth16 verifier for ${circuitName} circuit
 * @dev Auto-generated by snarkjs. Do not edit manually.
 */
`;

  // Find and replace the header section (everything before the contract declaration)
  const contractMatch = verifierContent.match(/contract\s+\w+/);
  if (contractMatch) {
    const contractIndex = verifierContent.indexOf(contractMatch[0]);
    const beforeContract = verifierContent.substring(0, contractIndex);
    const afterContract = verifierContent.substring(contractIndex);
    verifierContent = header + afterContract;
  }

  // Write final verifier
  writeFileSync(verifierPath, verifierContent);

  // Remove temp file
  try {
    const fs = await import("node:fs");
    fs.unlinkSync(tempVerifierPath);
  } catch {
    // Ignore if already deleted
  }

  log(`‚úÖ Generated ${contractName}.sol`, colors.green);
}

async function main() {
  log("üöÄ Generating Solidity verifiers...\n", colors.blue);

  // Check if build directory exists
  if (!existsSync(BUILD_DIR)) {
    log("‚ùå Build directory not found. Run 'npm run circuits:compile' first.", colors.red);
    process.exit(1);
  }

  // Create verifiers directory
  if (!existsSync(VERIFIERS_DIR)) {
    mkdirSync(VERIFIERS_DIR, { recursive: true });
  }

  // Find all .zkey files
  const files = readdirSync(BUILD_DIR);
  const zkeyFiles = files.filter(f => f.endsWith(".zkey"));

  if (zkeyFiles.length === 0) {
    log("‚ö†Ô∏è  No compiled circuits found. Run 'npm run circuits:compile' first.", colors.yellow);
    return;
  }

  log(`Found ${zkeyFiles.length} compiled circuit(s)\n`, colors.blue);

  // Generate verifier for each circuit
  for (const zkeyFile of zkeyFiles) {
    const circuitName = zkeyFile.replace(".zkey", "");
    try {
      await generateVerifier(circuitName);
    } catch (error: any) {
      log(`\n‚ùå Error generating verifier for ${circuitName}: ${error.message}`, colors.red);
      process.exit(1);
    }
  }

  log("\n‚ú® All verifiers generated successfully!", colors.green);
  log(`üìÅ Verifiers saved to: ${VERIFIERS_DIR}\n`, colors.blue);
}

main();

